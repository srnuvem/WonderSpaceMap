<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pan and Zoom Image</title>
    <style>
        body,
        html {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        #canvas {
            width: 100%;
            height: 100%;
            background: #111;
        }
    </style>
</head>

<body>
    <canvas id="canvas"></canvas>
    <script>
        let canvas = document.getElementById("canvas");
        let ctx = canvas.getContext('2d');

        let cameraOffset = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
        let cameraZoom = 1;
        let MAX_ZOOM = 5;
        let MIN_ZOOM = 0.1;
        let SCROLL_SENSITIVITY = 0.0005;

        const canvas = document.getElementById('myCanvas');
        const ctx = canvas.getContext('2d');
        // const fator = canvas.width / 960
        const fator = canvas.width / 480 * 64

        const astros = {
            "Marte": { cor: "Red", grau: 0, divisores: 0, diametroOrbita: 0 * fator, diametro: 0.65 * fator },
            "Phobos": { cor: "White", grau: 270, divisores: 1, diametroOrbita: 20 * fator, diametro: 0.04 * fator },
            "Deimos": { cor: "LightGray", grau: 90, divisores: 1, diametroOrbita: 20 * fator, diametro: 0.03 * fator },
        };

        function drawStars() {
            const numStars = 150;
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = 'white';

            for (let i = 0; i < numStars; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                ctx.fillRect(x, y, 2, 2);
            }
        }

        function drawBody(astro) {
            const { diametroOrbita, cor, grau, diametro } = astros[astro];

            const raioOrbita = diametroOrbita / 8;
            const x = canvas.width / 2 + raioOrbita * Math.cos((grau - 90) * (Math.PI / 180));
            const y = canvas.height / 2 + raioOrbita * Math.sin((grau - 90) * (Math.PI / 180));

            ctx.strokeStyle = cor;
            ctx.setLineDash([5, 2]); // 5 é o tamanho do traço, 5 é o espaço entre traços
            ctx.lineWidth = 1;

            ctx.beginPath();
            ctx.arc(canvas.width / 2, canvas.height / 2, raioOrbita, 0, 2 * Math.PI);
            ctx.stroke();

            ctx.fillStyle = cor;
            ctx.beginPath();
            ctx.arc(x, y, diametro, 0, 2 * Math.PI);
            ctx.fill();

            ctx.fillStyle = "white";
            ctx.font = "12px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "bottom";
            ctx.fillText(astro, x, y - 0.1 * fator);
        }

        function drawGuideLine(astro) {
            const { diametroOrbita, cor, grau } = astros[astro];

            const raioOrbita = diametroOrbita / 8;
            const x = canvas.width / 2 + raioOrbita * Math.cos((grau - 90) * (Math.PI / 180));
            const y = canvas.height / 2 + raioOrbita * Math.sin((grau - 90) * (Math.PI / 180));

            ctx.strokeStyle = cor;
            ctx.setLineDash([5, 2]); // 5 é o tamanho do traço, 5 é o espaço entre traços
            ctx.lineWidth = 1;

            ctx.beginPath();
            ctx.arc(canvas.width / 2, canvas.height / 2, raioOrbita, 0, 2 * Math.PI);
            ctx.stroke();
        }

        function drawMarkers(astro) {
            const divisores = astros[astro].divisores;

            for (let i = 0; i < divisores; i++) {
                const angulo = (360 / divisores) * i;

                const { diametroOrbita, cor } = astros[astro];
                const grau = angulo;

                const lineSize = fator / 4;
                const midSize = lineSize / 2;

                const raioOrbita = diametroOrbita / 8;
                const x = canvas.width / 2 + raioOrbita * Math.cos((grau - 90) * (Math.PI / 180));
                const y = canvas.height / 2 + raioOrbita * Math.sin((grau - 90) * (Math.PI / 180));

                const inicioX = x - midSize * Math.cos((grau - 90) * (Math.PI / 180));
                const inicioY = y - midSize * Math.sin((grau - 90) * (Math.PI / 180));

                const fimX = inicioX + lineSize * Math.cos((grau - 90) * (Math.PI / 180));
                const fimY = inicioY + lineSize * Math.sin((grau - 90) * (Math.PI / 180));

                ctx.strokeStyle = cor;
                ctx.setLineDash([]); // 5 é o tamanho do traço, 5 é o espaço entre traços
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(inicioX, inicioY);
                ctx.lineTo(fimX, fimY);
                ctx.stroke();
            }
        }

        function drawAsteroids() {
            const numAsteroids = 5000; // Número de asteroides a serem desenhados
            const asteroidSize = fator / 16
            const raioOrbita = astros["Orientacao Cinturão de Asteroides"].diametroOrbita / 8; // Raio da órbita
            const cor = astros["Orientacao Cinturão de Asteroides"].cor; // Cor dos asteroides

            ctx.fillStyle = cor;


            for (let i = 0; i < numAsteroids; i++) {
                // Gerar uma posição aleatória ao longo da órbita
                const angulo = Math.random() * 360;
                const raioVariacao = Math.random() * fator; // Variacao aleatoria de até 5 pixels para cima ou para baixo
                const raioFinal = raioOrbita + raioVariacao - fator / 2;
                const x = canvas.width / 2 + raioFinal * Math.cos((angulo - 90) * (Math.PI / 180));
                const y = canvas.height / 2 + raioFinal * Math.sin((angulo - 90) * (Math.PI / 180));

                // Desenhar o asteroide
                ctx.fillRect(x, y, asteroidSize, asteroidSize);
            }
        }

        function saveImage() {
            const dataURL = canvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.href = dataURL;
            link.download = 'orbitas_celestes_4k.png';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function drawSun() {
            const { diametroOrbita, cor, grau, diametro } = astros["Marte"];

            ctx.fillStyle = cor;
            ctx.beginPath();
            ctx.arc(canvas.width / 2, canvas.height / 2, diametro, 0, 2 * Math.PI);
            ctx.fill();

            ctx.fillStyle = "black";
            ctx.font = "12px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText("Marte", canvas.width / 2, canvas.height / 2
            );
        }

        function draw() {

                // Translate to the canvas centre before zooming - so you'll always zoom on what you're looking directly at
                ctx.translate(window.innerWidth / 2, window.innerHeight / 2)
                ctx.scale(cameraZoom, cameraZoom)
                ctx.translate(-window.innerWidth / 2 + cameraOffset.x, -window.innerHeight / 2 + cameraOffset.y)
                ctx.clearRect(0, 0, window.innerWidth, window.innerHeight)
                ctx.fillStyle = "#991111"
                drawRect(-50, -50, 100, 100)

                ctx.fillStyle = "#eecc77"
                drawRect(-35, -35, 20, 20)
                drawRect(15, -35, 20, 20)
                drawRect(-35, 15, 70, 20)

                ctx.fillStyle = "#fff"
                drawText("Simple Pan and Zoom Canvas", -255, -100, 32, "courier")

                ctx.rotate(-31 * Math.PI / 180)
                ctx.fillStyle = `#${(Math.round(Date.now() / 40) % 4096).toString(16)}`
                drawText("Now with touch!", -110, 100, 32, "courier")

                ctx.fillStyle = "#fff"
                ctx.rotate(31 * Math.PI / 180)

                drawText("Wow, you found me!", -260, -2000, 48, "courier")

                requestAnimationFrame(draw)
            
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
            ctx.save();
            ctx.translate(window.innerWidth / 2, window.innerHeight / 2);
            ctx.scale(cameraZoom, cameraZoom);
            ctx.translate(-window.innerWidth / 2 + cameraOffset.x, -window.innerHeight / 2 + cameraOffset.y);

            drawStars();

            // drawAsteroids();
            for (const astro in astros) {
                if (astro !== "Marte") {
                    if (astro.includes("Orientacao")) {
                        drawGuideLine(astro)
                    } else {
                        drawBody(astro);
                    }
                    drawMarkers(astro);

                }
            }

            drawSun();

            ctx.restore();
            requestAnimationFrame(draw);
        }

        function drawRect(x, y, width, height) {
            ctx.fillRect(x, y, width, height);
        }

        function drawText(text, x, y, size, font) {
            ctx.font = `${size}px ${font}`;
            ctx.fillText(text, x, y);
        }

        let isDragging = false;
        let dragStart = { x: 0, y: 0 };

        function onPointerDown(e) {
            isDragging = true;
            dragStart.x = getEventLocation(e).x / cameraZoom - cameraOffset.x;
            dragStart.y = getEventLocation(e).y / cameraZoom - cameraOffset.y;
        }

        function onPointerUp(e) {
            isDragging = false;
        }

        function onPointerMove(e) {
            if (isDragging) {
                cameraOffset.x = getEventLocation(e).x / cameraZoom - dragStart.x;
                cameraOffset.y = getEventLocation(e).y / cameraZoom - dragStart.y;
            }
        }

        function handleTouch(e, singleTouchHandler) {
            if (e.touches.length == 1) {
                singleTouchHandler(e);
            } else if (e.type == "touchmove" && e.touches.length == 2) {
                isDragging = false;
                handlePinch(e);
            }
        }

        let initialPinchDistance = null;
        let lastZoom = cameraZoom;

        function handlePinch(e) {
            e.preventDefault();

            let touch1 = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            let touch2 = { x: e.touches[1].clientX, y: e.touches[1].clientY };

            let currentDistance = (touch1.x - touch2.x) ** 2 + (touch1.y - touch2.y) ** 2;

            if (initialPinchDistance == null) {
                initialPinchDistance = currentDistance;
            } else {
                adjustZoom(null, currentDistance / initialPinchDistance);
            }
        }

        function adjustZoom(zoomAmount, zoomFactor) {
            if (!isDragging) {
                if (zoomAmount) {
                    cameraZoom += zoomAmount;
                } else if (zoomFactor) {
                    cameraZoom = zoomFactor * lastZoom;
                }

                cameraZoom = Math.min(cameraZoom, MAX_ZOOM);
                cameraZoom = Math.max(cameraZoom, MIN_ZOOM);

                lastZoom = cameraZoom;
            }
        }

        function getEventLocation(e) {
            if (e.touches && e.touches.length == 1) {
                return { x: e.touches[0].clientX, y: e.touches[0].clientY };
            } else if (e.clientX && e.clientY) {
                return { x: e.clientX, y: e.clientY };
            }
        }

        canvas.addEventListener('mousedown', onPointerDown);
        canvas.addEventListener('touchstart', (e) => handleTouch(e, onPointerDown));
        canvas.addEventListener('mouseup', onPointerUp);
        canvas.addEventListener('touchend', (e) => handleTouch(e, onPointerUp));
        canvas.addEventListener('mousemove', onPointerMove);
        canvas.addEventListener('touchmove', (e) => handleTouch(e, onPointerMove));
        canvas.addEventListener('wheel', (e) => adjustZoom(e.deltaY * SCROLL_SENSITIVITY));

        draw();
    </script>
</body>

</html>